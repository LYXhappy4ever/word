<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å•è¯è®­ç»ƒå™¨ v30.0 (ç²¾ç®€ä¿®å¤ç‰ˆ)</title>
    <style>
        :root {
            --primary: #4F46E5;
            --primary-bg: #EEF2FF;
            --bg-body: #F3F4F6;
            --bg-card: #FFFFFF;
            --text-main: #1F2937;
            --text-sub: #6B7280;
            --danger: #EF4444;
            --success: #10B981;
            --warning: #F59E0B;
            --focus-ring: #818cf8;
            --select-border: #3b82f6;
            --select-bg: rgba(59, 130, 246, 0.2);
            --radius: 12px;
            --font-stack: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        html { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; padding: 0; font-family: var(--font-stack); background: var(--bg-body); color: var(--text-main); height: 100vh; overflow: hidden; display: flex; flex-direction: column; user-select: none; }
        * { box-sizing: border-box; }

        /* --- é€šç”¨ç»„ä»¶ --- */
        .btn { border: none; padding: 8px 14px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 13px; display: inline-flex; align-items: center; justify-content: center; gap: 5px; outline: none; white-space: nowrap; }
        .btn:active { transform: scale(0.96); }
        .btn-primary { background: var(--primary); color: white; box-shadow: 0 4px 6px -1px rgba(79, 70, 229, 0.2); }
        .btn-ghost { background: transparent; color: var(--text-sub); }
        .btn-ghost:hover { background: rgba(0,0,0,0.05); color: var(--primary); }
        .btn-outline { border: 1px solid #E5E7EB; background: white; color: var(--text-main); }
        .btn-icon { padding: 8px; border-radius: 50%; width: 32px; height: 32px; }
        
        select { padding: 8px 30px 8px 12px; border-radius: 8px; border: 1px solid #d1d5db; background: white; font-size: 13px; cursor: pointer; appearance: none; }
        .hidden { display: none !important; }
        .view { flex: 1; display: flex; flex-direction: column; height: 100%; overflow: hidden; }

        /* --- é¢åŒ…å±‘å¯¼èˆª --- */
        .breadcrumb-bar {
            padding: 10px 16px; background: white; border-bottom: 1px solid #e5e7eb; display: flex; align-items: center; gap: 5px; font-size: 14px; color: var(--text-sub); overflow-x: auto; flex-shrink: 0;
        }
        .crumb { cursor: pointer; padding: 4px 8px; border-radius: 6px; transition: background 0.2s; }
        .crumb:hover { background: #f3f4f6; color: var(--primary); }
        .crumb.active { font-weight: bold; color: var(--text-main); cursor: default; }
        .crumb-separator { color: #d1d5db; }

        /* --- ä¹¦æ¶è§†å›¾ --- */
        header { background: rgba(255,255,255,0.95); backdrop-filter: blur(8px); padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e5e7eb; z-index: 50; flex-shrink: 0; }
        
        #bookshelf-view { overflow: hidden; display: flex; flex-direction: column; }
        .file-area { flex: 1; overflow-y: auto; padding: 16px; position: relative; } 
        
        .toolbar { display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
        
        .book-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 12px; padding-bottom: 60px; }
        
        .item-card {
            background: var(--bg-card); border-radius: var(--radius); padding: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05); border: 2px solid transparent;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            height: 150px; position: relative; transition: all 0.2s; cursor: pointer;
            justify-content: space-between; z-index: 1;
        }
        .item-card:hover { transform: translateY(-2px); box-shadow: 0 8px 12px -3px rgba(0,0,0,0.1); border-color: #e5e7eb; z-index: 10; }
        .item-card.selected { background-color: var(--primary-bg); border-color: var(--select-border); box-shadow: 0 0 0 2px var(--select-bg); }
        .item-card.drag-target { border: 2px dashed var(--success); transform: scale(1.05); z-index: 20; background: #ecfdf5; }

        .item-content { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; pointer-events: none; }
        .item-icon { font-size: 36px; margin-bottom: 5px; }
        .item-name { font-size: 14px; font-weight: 600; color: #374151; width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding: 0 5px; }
        
        .item-meta { 
            font-size: 11px; color: #9ca3af; margin-top: 4px; pointer-events: auto;
            padding: 2px 6px; border-radius: 4px; transition: background 0.2s;
        }
        .item-meta:hover { background: #f3f4f6; color: var(--primary); }

        .item-card[data-type="folder"] .item-icon { color: #F59E0B; }
        .item-actions-row { display: flex; gap: 2px; width: 100%; justify-content: center; opacity: 0; transition: opacity 0.2s; margin-top: 5px; z-index: 5;}
        .item-card:hover .item-actions-row { opacity: 1; }

        /* æ¡†é€‰é€‰æ¡† */
        #selection-marquee {
            position: fixed; border: 1px solid var(--select-border); background-color: var(--select-bg);
            display: none; z-index: 9999; pointer-events: none;
        }
        
        /* ä¸‹æ‹‰èœå• */
        .menu-dropdown {
            position: absolute; top: 100%; right: 0; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none; flex-direction: column; z-index: 200; min-width: 100px; overflow: hidden;
        }
        .menu-dropdown.show { display: flex; }
        .menu-item { padding: 8px 12px; text-align: left; background: white; border: none; font-size: 12px; cursor: pointer; width: 100%; }
        .menu-item:hover { background: #f3f4f6; }
        .menu-item.danger { color: red; }

        /* è®­ç»ƒè§†å›¾ */
        .full-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; background: var(--bg-body); display: flex; flex-direction: column; }
        .timer-bar { height: 4px; background: #e5e7eb; width: 100%; }
        .timer-progress { height: 100%; background: var(--primary); width: 100%; transition: width 1s linear; }
        .training-container { flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; }
        .layout-grid { display: grid; gap: 10px; width: 100%; height: 100%; transition: all 0.3s ease; }
        @media (min-width: 768px) { .layout-grid { grid-template-columns: repeat(var(--cols, 4), 1fr); grid-template-rows: repeat(2, 1fr); height: 100%; max-height: 85vh; } .word-card { height: 100% !important; } }
        @media (max-width: 768px) { .layout-grid { grid-template-columns: repeat(2, 1fr); grid-auto-rows: 160px; height: auto; padding-bottom: 80px; } }
        
        .word-card { background: transparent; perspective: 1000px; height: 160px; cursor: pointer; position: relative; touch-action: manipulation; }
        .card-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); transform-style: preserve-3d; border-radius: var(--radius); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05); }
        .word-card.is-reviewing .card-inner { transform: rotateY(180deg); }
        .word-card.is-mastered .card-inner { transform: rotateY(0deg); } 
        .card-front, .card-back { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; border-radius: var(--radius); border: 2px solid #e5e7eb; background: white; overflow: hidden; display: flex; flex-direction: column; }
        .card-front { z-index: 2; background: white; color: var(--text-main); }
        .card-back { z-index: 1; transform: rotateY(180deg); background: #FFF1F2; border-color: #FECACA; }
        .word-card.is-review-item .card-front { border-style: dashed; border-color: #818cf8; background: #f5f3ff; }
        .word-card.is-mastered .card-front { border: 3px solid var(--success); background-color: #ecfdf5; border-style: solid; }
        .check-mark { position: absolute; top: 8px; right: 8px; color: var(--success); font-size: 20px; opacity: 0; transform: scale(0.5); transition: all 0.2s; }
        .word-card.is-mastered .check-mark { opacity: 1; transform: scale(1); }
        .section-top { height: 45%; width: 100%; display: flex; align-items: center; justify-content: center; padding: 0 10px; }
        .word-text { font-size: 22px; font-weight: 800; color: var(--text-main); overflow: hidden; text-overflow: ellipsis; }
        .section-bottom { height: 55%; width: 100%; padding: 10px; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.01); opacity: 0; transition: opacity 0.2s ease; }
        .word-card:hover .section-bottom { opacity: 1; }

        /* æ¨¡æ€æ¡† & Toast */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 200; backdrop-filter: blur(2px); opacity: 0; pointer-events: none; }
        .modal-overlay:not(.hidden) { opacity: 1; pointer-events: auto; }
        .modal { background: white; width: 90%; max-width: 450px; border-radius: 20px; padding: 24px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        #toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(17, 24, 39, 0.95); color: white; padding: 10px 24px; border-radius: 30px; font-size: 14px; z-index: 999; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        
        #pool-view { background: #f0f4f8; }
        .pool-container { padding: 20px; overflow-y: auto; flex: 1; display: flex; flex-wrap: wrap; gap: 10px; align-content: flex-start; justify-content: center; }
        .bubble { 
            background: white; border: 1px solid #e2e8f0; border-radius: 20px; padding: 8px 16px; cursor: pointer; user-select: none; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05); margin: 5px;
        }
        .bubble:active { transform: scale(1.05); }
    </style>
</head>
<body>

    <div id="selection-marquee"></div>

    <div id="bookshelf-view" class="view">
        <header>
            <h1>ğŸ§  è®°å¿†å¤§å¸ˆ</h1>
            <div style="display: flex; gap: 8px;">
                <button class="btn btn-outline" onclick="FolderSys.createFolder()">ğŸ“‚ æ–°å»ºæ–‡ä»¶å¤¹</button>
                <button class="btn btn-ghost" onclick="SyncSys.exportData()">ğŸ“¤ å¤‡ä»½</button>
                <button class="btn btn-primary" onclick="App.showImportModal()">+ å¯¼å…¥</button>
            </div>
        </header>
        
        <div class="breadcrumb-bar" id="breadcrumb">
            <span class="crumb active">æ ¹ç›®å½•</span>
        </div>

        <div id="file-area" class="file-area" onmousedown="SelectionSys.start(event)">
            <div style="max-width: 1200px; margin: 0 auto;">
                <div class="toolbar">
                    <select id="sort-pref" onchange="App.savePref()">
                        <option value="random" selected>ğŸ² æ’åºï¼šéšæœºä¹±åº (é»˜è®¤)</option>
                        <option value="unmastered">âš¡ æ’åºï¼šæœªæŒæ¡ä¼˜å…ˆ</option>
                        <option value="az">ğŸ”¤ æ’åºï¼šA-Z</option>
                    </select>
                    <span style="color:#999; font-size:12px; margin-left:auto; align-self:center;">æç¤ºï¼šæŒ‰ä½æ‹–æ‹½æ¡†é€‰ Â· å•å‡»è¿›å…¥ Â· Ctrl+C/V</span>
                </div>
                
                <div id="book-list" class="book-list"></div>
            </div>
        </div>
    </div>

    <div id="training-view" class="full-screen hidden">
        <header>
            <button class="btn btn-ghost" onclick="App.endTraining()">âœ• é€€å‡º</button>
            <div style="text-align: center;">
                <h1 id="train-book-title" style="font-size: 15px; margin:0;">è®­ç»ƒä¸­</h1>
                <span style="font-size: 11px; color: var(--text-sub)">è½®æ¬¡ <span id="round-count">1</span> <span id="review-badge" class="hidden" style="color:#4F46E5; font-weight:bold; margin-left:5px;">(å¤ä¹ è½®)</span></span>
            </div>
            <div style="display:flex; gap:5px;">
                <button class="btn btn-ghost" onclick="Training.toggleAllMeanings()">ğŸ‘ï¸</button>
                <button class="btn btn-ghost" onclick="Training.togglePause()">â¸</button>
            </div>
        </header>
        <div class="timer-bar"><div id="timer-progress" class="timer-progress"></div></div>
        <div id="card-container" class="training-container layout-grid"></div>
        <div style="padding: 12px; background: white; text-align: center;">
             <button class="btn btn-outline" style="width: 200px;" onclick="Training.finishBatch()">ğŸ“¥ ç»“ç®— (Enter)</button>
        </div>
        <div id="pause-overlay" class="pause-overlay hidden">
            <h1>â¸</h1><button class="btn btn-primary" onclick="Training.togglePause()">ç»§ç»­</button>
        </div>
    </div>
    
    <div id="pool-view" class="full-screen hidden">
        <header><button class="btn btn-ghost" onclick="Pool.close()">â¬… è¿”å›</button> <h1>é€Ÿç­›è¯æ± </h1> <span></span></header>
        <div id="pool-container" class="pool-container"></div>
    </div>

    <div id="import-modal" class="modal-overlay hidden">
        <div class="modal">
            <h3>å¯¼å…¥ / æ–°å»º</h3>
            <div style="margin-bottom:15px; padding-bottom:15px; border-bottom:1px solid #eee;">
                 <button class="btn btn-outline" style="width:100%;" onclick="document.getElementById('file-input').click()">ğŸ“‚ é€‰æ‹©æ–‡ä»¶ (txt/json)</button>
                 <input type="file" id="file-input" class="hidden" multiple onchange="App.handleFileInput(this)">
            </div>
            <textarea id="import-text" class="code-input" placeholder="ç›´æ¥ç²˜è´´æ–‡æœ¬..."></textarea>
            <input type="text" id="import-name-input" placeholder="åç§°" style="width:100%; padding:8px; border:1px solid #eee; border-radius:8px; margin-top:5px;">
            <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:15px;">
                <button class="btn btn-ghost" onclick="document.getElementById('import-modal').classList.add('hidden')">å–æ¶ˆ</button>
                <button class="btn btn-primary" onclick="App.processImport()">ç¡®è®¤</button>
            </div>
        </div>
    </div>

    <div id="toast">âœ… æ“ä½œæˆåŠŸ</div>

<script>
const Utils = {
    uuid: () => Date.now().toString(36) + Math.random().toString(36).substr(2),
    toast: (msg, type='success') => {
        const t = document.getElementById('toast');
        t.innerText = (type==='error'?'âŒ ':'âœ… ') + msg;
        t.style.opacity = 1; t.style.bottom = '40px';
        setTimeout(() => { t.style.opacity = 0; t.style.bottom = '30px'; }, 2000);
    },
    copyToClipboard: (text) => {
        navigator.clipboard.writeText(text).then(() => {
            Utils.toast('å·²å¤åˆ¶: ' + text);
        }).catch(err => {
            console.error('Copy failed', err);
            Utils.toast('å¤åˆ¶å¤±è´¥', 'error');
        });
    },
    shuffle: (array) => {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    }
};

const StorageManager = {
    getKey: (id) => id.startsWith('bk_') ? id : 'bk_' + id,
    save: (id, val) => { try { localStorage.setItem(StorageManager.getKey(id), JSON.stringify(val)); } catch(e) { Utils.toast('å­˜å‚¨å·²æ»¡', 'error'); } },
    get: (id) => { try { return JSON.parse(localStorage.getItem(StorageManager.getKey(id))); } catch(e) { return null; } },
    remove: (id) => localStorage.removeItem(StorageManager.getKey(id)),
    getAllItems: () => {
        const items = [];
        for(let i=0; i<localStorage.length; i++) {
            const k = localStorage.key(i);
            if(k.startsWith('bk_')) {
                try {
                    const item = JSON.parse(localStorage.getItem(k));
                    if (!item.parentId) { item.parentId = 'root'; localStorage.setItem(k, JSON.stringify(item)); }
                    if (!item.type) { item.type = 'book'; localStorage.setItem(k, JSON.stringify(item)); }
                    items.push(item);
                } catch(e) {}
            }
        }
        return items;
    },
    updateStatus: (bookId, wordId, status) => {
        const book = StorageManager.get(bookId);
        if(book) { 
            const w = book.words.find(x => x.id === wordId);
            if(w) { w.status = status; StorageManager.save(bookId, book); }
        }
    }
};

const FolderSys = {
    currentId: 'root',
    path: [{id: 'root', name: 'æ ¹ç›®å½•'}],
    createFolder: () => {
        const name = prompt("è¯·è¾“å…¥æ–‡ä»¶å¤¹åç§°ï¼š", "æ–°å»ºæ–‡ä»¶å¤¹");
        if(name) {
            const id = Utils.uuid();
            StorageManager.save(id, { id, name, type: 'folder', parentId: FolderSys.currentId });
            App.renderList();
        }
    },
    enter: (id, name) => {
        FolderSys.currentId = id;
        FolderSys.path.push({id, name});
        FolderSys.renderBreadcrumb();
        App.renderList();
        SelectionSys.clear();
    },
    navTo: (index) => {
        FolderSys.path = FolderSys.path.slice(0, index + 1);
        FolderSys.currentId = FolderSys.path[FolderSys.path.length-1].id;
        FolderSys.renderBreadcrumb();
        App.renderList();
        SelectionSys.clear();
    },
    renderBreadcrumb: () => {
        const bc = document.getElementById('breadcrumb');
        bc.innerHTML = '';
        FolderSys.path.forEach((p, idx) => {
            if(idx > 0) { const sp = document.createElement('span'); sp.className='crumb-separator'; sp.innerText='>'; bc.appendChild(sp); }
            const el = document.createElement('span');
            el.className = `crumb ${idx === FolderSys.path.length-1 ? 'active' : ''}`;
            el.innerText = p.name;
            el.onclick = () => FolderSys.navTo(idx);
            bc.appendChild(el);
        });
    }
};

const SelectionSys = {
    selectedIds: new Set(),
    isSelecting: false,
    startPos: {x:0, y:0},
    clipboard: { op: null, items: [] }, 

    start: (e) => {
        if (e.target.closest('.item-card')) return;
        
        SelectionSys.isSelecting = true;
        SelectionSys.startPos = { x: e.pageX, y: e.pageY };
        const marquee = document.getElementById('selection-marquee');
        marquee.style.display = 'block';
        marquee.style.left = e.pageX + 'px';
        marquee.style.top = e.pageY + 'px';
        marquee.style.width = '0px';
        marquee.style.height = '0px';
        if (!e.ctrlKey && !e.shiftKey) SelectionSys.clear();
        document.addEventListener('mousemove', SelectionSys.move);
        document.addEventListener('mouseup', SelectionSys.end);
    },
    move: (e) => {
        if (!SelectionSys.isSelecting) return;
        const marquee = document.getElementById('selection-marquee');
        const currentX = e.pageX;
        const currentY = e.pageY;
        
        const width = Math.abs(currentX - SelectionSys.startPos.x);
        const height = Math.abs(currentY - SelectionSys.startPos.y);
        const left = Math.min(currentX, SelectionSys.startPos.x);
        const top = Math.min(currentY, SelectionSys.startPos.y);
        
        marquee.style.width = width + 'px';
        marquee.style.height = height + 'px';
        marquee.style.left = left + 'px';
        marquee.style.top = top + 'px';
        
        const rect = { left, top, right: left+width, bottom: top+height };
        document.querySelectorAll('.item-card').forEach(card => {
            const cardRect = card.getBoundingClientRect();
            const cLeft = cardRect.left + window.scrollX;
            const cTop = cardRect.top + window.scrollY;
            const cRight = cLeft + cardRect.width;
            const cBottom = cTop + cardRect.height;
            const intersect = !(rect.left > cRight || rect.right < cLeft || rect.top > cBottom || rect.bottom < cTop);
            if (intersect) {
                SelectionSys.selectedIds.add(card.dataset.id);
                card.classList.add('selected');
            }
        });
    },
    end: () => {
        SelectionSys.isSelecting = false;
        document.getElementById('selection-marquee').style.display = 'none';
        document.removeEventListener('mousemove', SelectionSys.move);
        document.removeEventListener('mouseup', SelectionSys.end);
    },
    toggle: (id, multi) => {
        if (!multi) SelectionSys.clear();
        if (SelectionSys.selectedIds.has(id)) {
            SelectionSys.selectedIds.delete(id);
            document.querySelector(`.item-card[data-id="${id}"]`)?.classList.remove('selected');
        } else {
            SelectionSys.selectedIds.add(id);
            document.querySelector(`.item-card[data-id="${id}"]`)?.classList.add('selected');
        }
    },
    clear: () => {
        SelectionSys.selectedIds.clear();
        document.querySelectorAll('.item-card.selected').forEach(el => el.classList.remove('selected'));
    },
    handleKey: (e) => {
        if (document.getElementById('bookshelf-view').classList.contains('hidden')) return;
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        // ä½¿ç”¨ e.code ä¿®å¤å¤§å°å†™/è¾“å…¥æ³•ä¸‹çš„å¿«æ·é”®é—®é¢˜
        if (e.code === 'Delete' || e.code === 'Backspace') {
            if (SelectionSys.selectedIds.size > 0 && confirm(`åˆ é™¤é€‰ä¸­çš„ ${SelectionSys.selectedIds.size} é¡¹ï¼Ÿ`)) {
                SelectionSys.selectedIds.forEach(id => {
                    const item = StorageManager.get(id);
                    if (item && item.isSystem) return; 
                    StorageManager.remove(id);
                });
                SelectionSys.clear();
                App.renderList();
            }
        }
        else if (e.ctrlKey && e.code === 'KeyC') { 
            SelectionSys.clipboard = { op: 'copy', items: Array.from(SelectionSys.selectedIds) }; 
            Utils.toast(`å¤åˆ¶äº† ${SelectionSys.clipboard.items.length} é¡¹`); 
        }
        else if (e.ctrlKey && e.code === 'KeyX') { 
            SelectionSys.clipboard = { op: 'cut', items: Array.from(SelectionSys.selectedIds) }; 
            Utils.toast(`å‰ªåˆ‡äº† ${SelectionSys.clipboard.items.length} é¡¹`); 
        }
        else if (e.ctrlKey && e.code === 'KeyV') {
            if (!SelectionSys.clipboard.items.length) return;
            let count = 0;
            SelectionSys.clipboard.items.forEach(oldId => {
                const item = StorageManager.get(oldId);
                if (!item) return;
                if (SelectionSys.clipboard.op === 'cut') {
                    item.parentId = FolderSys.currentId;
                    StorageManager.save(item.id, item);
                    count++;
                } else {
                    const newId = Utils.uuid();
                    const newItem = { ...item, id: newId, parentId: FolderSys.currentId, name: item.name + ' å‰¯æœ¬' };
                    if(newItem.words) newItem.words = newItem.words.map(w => ({...w, id: Utils.uuid()}));
                    StorageManager.save(newId, newItem);
                    count++;
                }
            });
            if (SelectionSys.clipboard.op === 'cut') SelectionSys.clipboard.items = []; 
            App.renderList();
            Utils.toast(SelectionSys.clipboard.op === 'cut' ? `ç§»åŠ¨ ${count} é¡¹` : `ç²˜è´´ ${count} é¡¹`);
        }
        else if (e.code === 'KeyA' && e.ctrlKey) { 
            e.preventDefault(); 
            document.querySelectorAll('.item-card').forEach(el => { 
                SelectionSys.selectedIds.add(el.dataset.id); 
                el.classList.add('selected'); 
            }); 
        }
    }
};

const App = {
    isManageMode: false,
    showRemainingMode: false,
    init: () => {
        if(!StorageManager.get('system_mistakes')) StorageManager.save('system_mistakes', {id:'system_mistakes', name:'ğŸ“… é”™é¢˜æœ¬', words:[], isSystem:true, type:'book', parentId: 'root'});
        App.loadPref();
        App.renderList();
        App.setupDragDrop();
        window.addEventListener('keydown', SelectionSys.handleKey);
        
        document.addEventListener('click', (e) => {
            if(!e.target.closest('.item-actions-row') && !e.target.closest('.menu-dropdown')) {
                document.querySelectorAll('.menu-dropdown').forEach(el => { el.classList.remove('show'); el.style.display='none'; });
            }
        });
    },
    
    loadPref: () => { document.getElementById('sort-pref').value = localStorage.getItem('sort_pref') || 'random'; },
    savePref: () => { localStorage.setItem('sort_pref', document.getElementById('sort-pref').value); },

    toggleMenu: (bookId, event) => {
        event.stopPropagation();
        const menu = document.getElementById(`menu-${bookId}`);
        const wasHidden = menu.style.display !== 'flex';
        document.querySelectorAll('.menu-dropdown').forEach(el => { el.classList.remove('show'); el.style.display='none'; });
        if(wasHidden) { menu.classList.add('show'); menu.style.display = 'flex'; }
    },

    toggleProgressMode: (event) => {
        event.stopPropagation();
        App.showRemainingMode = !App.showRemainingMode;
        App.renderList();
    },

    renderList: () => {
        const list = document.getElementById('book-list');
        list.innerHTML = '';
        const allItems = StorageManager.getAllItems();
        const currentItems = allItems.filter(item => {
            if (item.isSystem && FolderSys.currentId === 'root') return true;
            return item.parentId === FolderSys.currentId;
        });

        currentItems.sort((a, b) => {
            if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
            return a.id > b.id ? -1 : 1;
        });

        if (currentItems.length === 0) list.innerHTML = '<div style="grid-column:1/-1; text-align:center; color:#999; padding:40px;">æ­¤æ–‡ä»¶å¤¹ä¸ºç©º</div>';

        currentItems.forEach(item => {
            const el = document.createElement('div');
            el.className = `item-card ${SelectionSys.selectedIds.has(item.id) ? 'selected' : ''}`;
            el.dataset.id = item.id;
            el.dataset.type = item.type;
            el.draggable = true;
            
            el.ondragstart = (e) => {
                if (!SelectionSys.selectedIds.has(item.id)) { SelectionSys.clear(); SelectionSys.toggle(item.id, false); }
                e.dataTransfer.setData('json', JSON.stringify({ ids: Array.from(SelectionSys.selectedIds), type: item.type }));
            };
            el.ondragover = (e) => { e.preventDefault(); el.classList.add('drag-target'); };
            el.ondragleave = () => { el.classList.remove('drag-target'); };
            el.ondrop = (e) => App.handleDrop(e, item);
            
            el.onclick = () => { 
                if(item.type === 'folder') FolderSys.enter(item.id, item.name); 
                else Training.start(item.id); 
            };

            const icon = item.type === 'folder' ? 'ğŸ“' : 'ğŸ“˜';
            
            let metaHtml = '';
            if (item.type === 'book') {
                const total = item.words.length;
                const done = item.words.filter(w=>w.status===2).length;
                const remaining = total - done;
                const text = App.showRemainingMode ? `å¾…å­¦ ${remaining}` : `${done}/${total} å·²å­¦`;
                metaHtml = `<div class="item-meta" onclick="App.toggleProgressMode(event)" title="ç‚¹å‡»åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼">${text}</div>`;
            } else {
                metaHtml = `<div class="item-meta">æ–‡ä»¶å¤¹</div>`;
            }
            
            // ç§»é™¤äº† "ğŸ”€ æ‰“ä¹±é¡ºåº"
            const actions = !item.isSystem && item.type === 'book' ? `
                <div class="item-actions-row">
                    <button class="btn btn-ghost btn-icon" title="æ°”æ³¡ç­›é€‰" onclick="App.handlePoolMode('${item.id}', event)">ğŸŒŠ</button>
                    <button class="btn btn-ghost btn-icon" title="é‡å‘½å" onclick="App.handleRenameBook('${item.id}', event)">âœï¸</button>
                    <button class="btn btn-ghost btn-icon" title="æ›´å¤š" onclick="App.toggleMenu('${item.id}', event)">â‹®</button>
                </div>
                <div class="menu-dropdown" id="menu-${item.id}">
                    <button class="menu-item" onclick="App.handleDedupeBook('${item.id}', event)">ğŸ§¹ å»é‡</button>
                    <button class="menu-item" onclick="App.handleExportBook('${item.id}', event)">ğŸ“¥ å¯¼å‡º</button>
                    <button class="menu-item danger" onclick="App.handleDeleteBook('${item.id}', event)">ğŸ—‘ åˆ é™¤</button>
                </div>
            ` : (!item.isSystem ? `
                <div class="item-actions-row">
                    <button class="btn btn-ghost btn-icon" title="é‡å‘½å" onclick="App.handleRenameBook('${item.id}', event)">âœï¸</button>
                    <button class="btn btn-ghost btn-icon" title="åˆ é™¤" onclick="App.handleDeleteBook('${item.id}', event)">ğŸ—‘</button>
                </div>
            ` : `<div class="item-actions-row"></div>`);

            el.innerHTML = `
                <div class="item-content">
                    <div class="item-icon">${icon}</div>
                    <div class="item-name" title="${item.name}">${item.name}</div>
                    ${metaHtml}
                </div>
                ${actions}
            `;
            list.appendChild(el);
        });
    },

    handleDrop: (e, targetItem) => {
        e.preventDefault(); e.stopPropagation();
        document.querySelectorAll('.drag-target').forEach(el => el.classList.remove('drag-target'));
        try {
            const data = JSON.parse(e.dataTransfer.getData('json'));
            const ids = data.ids;
            if (targetItem.type === 'folder') {
                if (ids.includes(targetItem.id)) return;
                let count = 0;
                ids.forEach(id => {
                    const item = StorageManager.get(id);
                    if (item && item.parentId !== targetItem.id && !item.isSystem) {
                        item.parentId = targetItem.id; StorageManager.save(id, item); count++;
                    }
                });
                Utils.toast(`ç§»åŠ¨äº† ${count} é¡¹`); App.renderList();
            }
            else if (targetItem.type === 'book' && ids.length === 1 && ids[0] !== targetItem.id) {
                const srcItem = StorageManager.get(ids[0]);
                if (srcItem.type === 'book' && confirm(`åˆå¹¶ "${srcItem.name}" åˆ° "${targetItem.name}"ï¼Ÿ`)) {
                    const existMap = new Set(targetItem.words.map(w=>w.word));
                    srcItem.words.forEach(w => { if(!existMap.has(w.word)) targetItem.words.push(w); });
                    StorageManager.save(targetItem.id, targetItem); StorageManager.remove(srcItem.id);
                    App.renderList(); Utils.toast('åˆå¹¶å®Œæˆ');
                }
            }
        } catch(err) {}
    },
    
    handleDeleteBook: (bookId, event) => { event.stopPropagation(); if(confirm('ç¡®å®šåˆ é™¤ï¼Ÿ')) { StorageManager.remove(bookId); App.renderList(); } },
    handleRenameBook: (bookId, event) => {
        event.stopPropagation();
        const book = StorageManager.get(bookId);
        const newName = prompt("æ–°åç§°ï¼š", book.name);
        if (newName) { book.name = newName; StorageManager.save(bookId, book); App.renderList(); }
    },
    handleExportBook: (bookId, event) => {
        event.stopPropagation();
        const book = StorageManager.get(bookId);
        const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([JSON.stringify(book)], {type:'application/json'})); a.download = `${book.name}.json`; a.click();
    },
    handleDedupeBook: (bookId, event) => {
        event.stopPropagation();
        const book = StorageManager.get(bookId);
        const map = new Map();
        book.words.forEach(w => map.set(w.word, w));
        if(map.size < book.words.length && confirm(`å‘ç° ${book.words.length - map.size} ä¸ªé‡å¤ï¼Œæ˜¯å¦æ¸…ç†ï¼Ÿ`)) {
            book.words = Array.from(map.values());
            StorageManager.save(bookId, book); App.renderList(); Utils.toast("å·²å»é‡");
        } else { Utils.toast("æ— é‡å¤"); }
    },
    handlePoolMode: (bookId, event) => { event.stopPropagation(); Pool.start(bookId); },

    setupDragDrop: () => {
        const overlay = document.getElementById('drop-overlay');
        document.body.ondragenter = (e) => { if(e.dataTransfer.types.includes('Files')) overlay.classList.add('active'); };
        document.getElementById('drop-overlay').ondragleave = (e) => { if(e.target === overlay) overlay.classList.remove('active'); };
        document.body.ondragover = (e) => e.preventDefault();
        document.body.ondrop = (e) => {
            if(e.target.closest('.item-card')) return; 
            e.preventDefault(); overlay.classList.remove('active');
            if(e.dataTransfer.files.length > 0) Array.from(e.dataTransfer.files).forEach(f => SyncSys.handleImportFile(f));
        };
    },
    processImport: () => {
        const text = document.getElementById('import-text').value;
        const name = document.getElementById('import-name-input').value;
        if(text) {
            const words = SyncSys.parseText(text);
            const id = Utils.uuid();
            StorageManager.save(id, { id, name: name||'æ–°å•è¯æœ¬', words, type:'book', parentId: FolderSys.currentId, isSystem:false });
            document.getElementById('import-modal').classList.add('hidden');
            App.renderList();
        }
    },
    showImportModal: () => document.getElementById('import-modal').classList.remove('hidden'),
    handleFileInput: (input) => { Array.from(input.files).forEach(f => SyncSys.handleImportFile(f)); input.value=''; document.getElementById('import-modal').classList.add('hidden'); },
    endTraining: () => { 
        clearInterval(Training.timer); window.removeEventListener('keydown', Training.handleKeyDown);
        document.getElementById('training-view').classList.add('hidden'); 
        document.getElementById('bookshelf-view').classList.remove('hidden');
        App.renderList(); 
    }
};

const SyncSys = {
    exportData: () => { 
        const data = {};
        for(let i=0; i<localStorage.length; i++) { const k=localStorage.key(i); if(k.startsWith('bk_')) data[k]=localStorage.getItem(k); }
        const b = new Blob([JSON.stringify(data)],{type:'application/json'});
        const a = document.createElement('a'); a.href=URL.createObjectURL(b); a.download='backup.json'; a.click();
    },
    parseText: (text) => {
        const words = [];
        text.split('\n').forEach(line => {
            line = line.trim(); if(!line) return;
            const match = line.match(/^([^\s]+)\s+(?:(\/[^\/]+\/)\s+)?(.+)$/);
            if(match) words.push({word: match[1], meaning: match[3], status: 0, id: Utils.uuid()});
            else { const parts = line.split(/\s+/); if(parts.length>1) words.push({word: parts[0], meaning: parts.slice(1).join(' '), status: 0, id: Utils.uuid()}); }
        });
        return words;
    },
    handleImportFile: (file) => {
        const r = new FileReader();
        r.onload = (e) => {
            try {
                const json = JSON.parse(e.target.result);
                if(json.words && Array.isArray(json.words)) {
                    const id=Utils.uuid(); StorageManager.save(id, {...json, id, parentId: FolderSys.currentId, type:'book', isSystem:false});
                    App.renderList(); return;
                }
                throw new Error('Not JSON');
            } catch(err) {
                const words = SyncSys.parseText(e.target.result);
                if(words.length) {
                    const id=Utils.uuid();
                    const name = file.name.replace(/\.[^/.]+$/, "");
                    StorageManager.save(id, {id, name, words, type:'book', parentId: FolderSys.currentId, isSystem:false});
                    App.renderList();
                }
            }
        };
        r.readAsText(file);
    }
};

const Training = {
    queue: [], current: [], round: 0, masteredPool: [], currentBookId: null, timer: null,
    start: (id) => {
        const book = StorageManager.get(id);
        if(!book || !book.words.length) return Utils.toast('ç©ºä¹¦');
        Training.currentBookId = id;
        Training.masteredPool = book.words.filter(w=>w.status===2);
        const pending = book.words.filter(w=>w.status!==2);
        if(!pending.length) return Utils.toast('å·²å…¨éƒ¨æŒæ¡');
        
        const pref = document.getElementById('sort-pref').value;
        if(pref === 'random') Utils.shuffle(pending);
        else if(pref === 'az') pending.sort((a,b)=>a.word.localeCompare(b.word));
        
        Training.queue = pending;
        Training.round = 0;
        document.getElementById('bookshelf-view').classList.add('hidden');
        document.getElementById('training-view').classList.remove('hidden');
        document.getElementById('train-book-title').innerText = book.name;
        window.addEventListener('keydown', Training.handleKeyDown);
        Training.next();
    },
    next: () => {
        Training.round++;
        document.getElementById('round-count').innerText = Training.round;
        const isReviewRound = (Training.round % 3 === 0);
        const reviewBadge = document.getElementById('review-badge');
        let batch = [];
        if(isReviewRound && Training.masteredPool.length > 0) {
            reviewBadge.classList.remove('hidden');
            const pool = [...Training.masteredPool];
            Utils.shuffle(pool);
            const review = pool.slice(0, 2);
            const newWords = Training.queue.splice(0, 8);
            batch = [...newWords, ...review];
            Utils.shuffle(batch);
        } else {
            reviewBadge.classList.add('hidden');
            batch = Training.queue.splice(0, 8);
        }
        if(!batch.length) { alert('å®Œæˆ'); return App.endTraining(); }
        Training.current = batch.map(w=>({...w, status: w.status===2?2:0})); 
        Training.render();
        Training.startTimer();
        Training.setFocus(0, true);
    },
    startTimer: () => {
        clearInterval(Training.timer);
        Training.timeLeft = 60;
        const bar = document.getElementById('timer-progress');
        bar.style.transition = 'none'; bar.style.width = '100%'; bar.offsetHeight; bar.style.transition = 'width 1s linear';
        Training.timer = setInterval(() => {
            if(Training.isPaused) return; 
            Training.timeLeft--;
            bar.style.width = (Training.timeLeft/60)*100+'%'; 
            if(Training.timeLeft<=0) Training.finishBatch(); 
        }, 1000);
    },
    togglePause: () => {
        Training.isPaused = !Training.isPaused;
        const overlay = document.getElementById('pause-overlay');
        if(Training.isPaused) { overlay.classList.remove('hidden'); document.getElementById('timer-progress').style.transition = 'none'; } 
        else { overlay.classList.add('hidden'); document.getElementById('timer-progress').style.transition = 'width 1s linear'; }
    },
    render: () => {
        const c = document.getElementById('card-container'); c.innerHTML='';
        c.style.setProperty('--cols', Math.ceil(Training.current.length / 2));
        Training.current.forEach(w => {
            const el = document.createElement('div'); el.className = `word-card ${w.status===2?'is-mastered':''} ${Training.masteredPool.find(mp=>mp.id===w.id)?'is-review-item':''}`;
            el.id='card-'+w.id; el.draggable = true;
            el.ondragstart = (e) => { e.dataTransfer.setData('text/plain', w.word); };
            el.oncontextmenu = (e) => { e.preventDefault(); Utils.copyToClipboard(w.word); };
            el.innerHTML = `<div class="card-inner"><div class="card-front"><div class="check-mark">âœ…</div><div class="section-top"><div class="word-text" title="${w.word}">${w.word}</div></div><div class="section-bottom"></div></div><div class="card-back"><div class="section-top"><div class="word-text">${w.word}</div></div><div class="section-bottom"><div class="word-meaning">${w.meaning}</div></div></div>`;
            el.onclick = () => Training.handleCardClick(w.id);
            c.appendChild(el);
        });
    },
    handleCardClick: (id) => {
        if(Training.isPaused) return;
        Training.hasInteracted = true;
        const index = Training.current.findIndex(x => x.id === id);
        if(index === -1) return;
        const w = Training.current[index];
        const el = document.getElementById('card-' + id);
        Training.setFocus(index, false);
        if(w.status===2) { w.status=1; el.classList.remove('is-mastered'); el.classList.add('is-reviewing'); }
        else if(w.status===1) { w.status=2; el.classList.remove('is-reviewing'); el.classList.add('is-mastered'); }
        else { w.status=1; el.classList.add('is-reviewing'); }
        if(Training.current.every(x => x.status === 2)) setTimeout(Training.finishBatch, 500);
    },
    finishBatch: () => {
        if (!Training.hasInteracted && Training.timeLeft <= 0) { App.endTraining(); return; }
        const notMastered = Training.current.filter(w => w.status !== 2);
        if(notMastered.length) { 
            const mb = StorageManager.get('system_mistakes');
            notMastered.forEach(w => { 
                if(!mb.words.find(x=>x.word===w.word)) mb.words.unshift({...w, id:Utils.uuid(), status:0}); 
                if (Training.queue.findIndex(q => q.id === w.id) === -1) Training.queue.push(w); 
            });
            StorageManager.save('system_mistakes', mb);
            Utils.toast(`${notMastered.length} ä¸ªæœªæŒæ¡`); 
        } else { Utils.toast('å…¨å¯¹ï¼'); }
        Training.current.forEach(w => { StorageManager.updateStatus(Training.currentBookId, w.id, w.status); });
        Training.next();
    },
    setFocus: (index, isKeyboard=false) => {
        if (index < 0 || index >= Training.current.length) return;
        if(Training.focusIndex !== -1) document.getElementById('card-' + Training.current[Training.focusIndex].id)?.classList.remove('is-keyboard-focus');
        Training.focusIndex = index;
        if (isKeyboard) {
            const newEl = document.getElementById('card-' + Training.current[Training.focusIndex].id);
            if(newEl) { newEl.classList.add('is-keyboard-focus'); newEl.scrollIntoView({behavior: "smooth", block: "center"}); }
        }
    },
    toggleAllMeanings: () => document.querySelectorAll('.word-card').forEach(el=>el.classList.add('force-reveal')),
    handleKeyDown: (e) => {
        if(document.getElementById('training-view').classList.contains('hidden')) return;
        if(Training.isPaused && e.code !== 'KeyP') return;
        const isUp = e.code === 'KeyW' || e.code === 'ArrowUp';
        const isDown = e.code === 'KeyS' || e.code === 'ArrowDown';
        const isLeft = e.code === 'KeyA' || e.code === 'ArrowLeft';
        const isRight = e.code === 'KeyD' || e.code === 'ArrowRight';
        const isFlip = e.code === 'Space';
        const isEnter = e.code === 'Enter';
        
        if (e.code === 'KeyP') { Training.togglePause(); return; }
        if (isEnter) { Training.finishBatch(); return; }
        
        let cols = 2; 
        if (window.innerWidth >= 768) cols = Math.ceil(Training.current.length / 2);
        let nextIndex = Training.focusIndex;
        if (nextIndex === -1 && (isUp||isDown||isLeft||isRight)) { Training.setFocus(0, true); return; }

        if (isRight) { if ((nextIndex + 1) % cols !== 0) nextIndex++; } 
        else if (isLeft) { if (nextIndex % cols !== 0) nextIndex--; } 
        else if (isDown) { if (nextIndex + cols < Training.current.length) nextIndex += cols; } 
        else if (isUp) { if (nextIndex - cols >= 0) nextIndex -= cols; } 
        else if (isFlip) { e.preventDefault(); if (nextIndex !== -1) Training.handleCardClick(Training.current[nextIndex].id); Training.setFocus(nextIndex, true); }
        if (nextIndex !== Training.focusIndex && nextIndex < Training.current.length) Training.setFocus(nextIndex, true); 
    },
    hasInteracted: false, isPaused: false, timeLeft: 60, focusIndex: -1
};

const Pool = { 
    close: () => {
        document.getElementById('pool-view').classList.add('hidden');
        document.getElementById('bookshelf-view').classList.remove('hidden');
        App.renderList(); 
    },
    start: (bookId) => {
        Pool.currentBookId = bookId;
        const book = StorageManager.get(bookId);
        if(!book) return;
        const words = book.words.filter(w => w.status !== 2);
        if(words.length === 0) { Utils.toast("æœ¬ä¹¦å·²å…¨éƒ¨æŒæ¡ï¼"); return; }
        document.getElementById('bookshelf-view').classList.add('hidden');
        document.getElementById('pool-view').classList.remove('hidden');
        const container = document.getElementById('pool-container');
        container.innerHTML = '';
        Utils.shuffle(words);
        words.forEach(w => {
            const el = document.createElement('div'); el.className = 'bubble'; el.draggable = true; el.dataset.state = 'word'; 
            el.innerHTML = `<div class="bubble-layer layer-word">${w.word}</div><div class="bubble-layer layer-meaning">${w.meaning}</div>`;
            el.ondragstart = (e) => { e.dataTransfer.setData('text/plain', w.word); };
            el.oncontextmenu = (e) => { e.preventDefault(); Utils.copyToClipboard(w.word); };
            let pressTimer;
            const startPress = () => { pressTimer = setTimeout(() => { Utils.copyToClipboard(w.word); navigator.vibrate && navigator.vibrate(50); }, 600); };
            const cancelPress = () => clearTimeout(pressTimer);
            el.addEventListener('touchstart', startPress); el.addEventListener('touchend', cancelPress);
            el.addEventListener('touchmove', cancelPress); el.addEventListener('mousedown', startPress); el.addEventListener('mouseup', cancelPress); el.addEventListener('mouseleave', cancelPress);
            el.onclick = () => {
                if (el.actionTimer) clearTimeout(el.actionTimer);
                if (el.classList.contains('mastered')) { el.classList.remove('mastered', 'vanish'); el.dataset.state = 'word'; StorageManager.updateStatus(Pool.currentBookId, w.id, 0); return; }
                if (el.dataset.state === 'word') { el.dataset.state = 'meaning'; el.actionTimer = setTimeout(() => { if (el.dataset.state === 'meaning') el.dataset.state = 'word'; }, 5000); return; }
                if (el.dataset.state === 'meaning') { el.dataset.state = 'mastered'; el.classList.add('mastered'); StorageManager.updateStatus(Pool.currentBookId, w.id, 2); el.actionTimer = setTimeout(() => { el.classList.add('vanish'); }, 5000); }
            };
            container.appendChild(el);
        });
    }
};

window.onload = App.init;
</script>
</body>
</html>
